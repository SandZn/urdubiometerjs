/* eslint-env mocha */
'use strict'

var expect = require('chai').expect
var urdubiometerjs = require('../src/index.js')
var GraphParser = urdubiometerjs.GraphParser

/* Theses settings are generated by urdubiometer.serialize(). The source YAML is:
  tokens:
    a: [class_a]
    b: [class_b]
    c: [class_c]
    ' ': [wb]
  rules:
    a: A
    b: B
    <class_c> a: A(AFTER_CLASS_C)
    (<class_c> b) a: A(AFTER_B_AND_CLASS_C)
    (<class_c> b b) a: A(AFTER_BB_AND_CLASS_C)
    a <class_c>: A(BEFORE_CLASS_C)
    a (c <class_b>): A(BEFORE_C_AND_CLASS_B)
    c: C
    ' ': ' '
  onmatch_rules:
    -
      <class_a> <class_b> + <class_a> <class_b>: '!'
    -
      <class_a> + <class_b>: ','
  whitespace:
    default: ' '
    consolidate: True
    token_class: wb
 */

var settings = {
  '_graph': {
    'edge': {
      '0': {
        '1': {
          'token': 'a',
          'cost': -403
        },
        '8': {
          'token': 'b',
          'cost': -101
        },
        '10': {
          'token': 'c',
          'cost': -101
        },
        '12': {
          'token': ' ',
          'cost': -101
        }
      },
      '1': {
        '2': {
          'cost': -403,
          'constraints': {
            'prev_classes': ['class_c'],
            'prev_tokens': ['b', 'b']
          }
        },
        '3': {
          'cost': -302,
          'constraints': {
            'prev_classes': ['class_c'],
            'prev_tokens': ['b']
          }
        },
        '4': {
          'cost': -302,
          'constraints': {
            'next_tokens': ['c'],
            'next_classes': ['class_b']
          }
        },
        '5': {
          'cost': -201,
          'constraints': {
            'prev_classes': ['class_c']
          }
        },
        '6': {
          'cost': -201,
          'constraints': {
            'next_classes': ['class_c']
          }
        },
        '7': {
          'cost': -101
        }
      },
      '8': {
        '9': {
          'cost': -101
        }
      },
      '10': {
        '11': {
          'cost': -101
        }
      },
      '12': {
        '13': {
          'cost': -101
        }
      }
    },
    'node': {
      '0': {
        'type': 'Start',
        'token_children': {
          'a': 1,
          'b': 8,
          'c': 10,
          ' ': 12
        },
        'ordered_children': {
          'a': [1],
          'b': [8],
          'c': [10],
          ' ': [12]
        }
      },
      '1': {
        'type': 'token',
        'token': 'a',
        'rule_children': [2, 3, 4, 5, 6, 7],
        'ordered_children': {
          '__rules__': [2, 3, 4, 5, 6, 7]
        }
      },
      '2': {
        'type': 'rule',
        'rule_key': 0,
        'rule': ['A(AFTER_BB_AND_CLASS_C)', ['class_c'],
          ['b', 'b'],
          ['a'], null, null, -403
        ],
        'accepting': true,
        'ordered_children': {}
      },
      '3': {
        'type': 'rule',
        'rule_key': 1,
        'rule': ['A(AFTER_B_AND_CLASS_C)', ['class_c'],
          ['b'],
          ['a'], null, null, -302
        ],
        'accepting': true,
        'ordered_children': {}
      },
      '4': {
        'type': 'rule',
        'rule_key': 2,
        'rule': ['A(BEFORE_C_AND_CLASS_B)', null, null, ['a'],
          ['c'],
          ['class_b'], -302
        ],
        'accepting': true,
        'ordered_children': {}
      },
      '5': {
        'type': 'rule',
        'rule_key': 3,
        'rule': ['A(AFTER_CLASS_C)', ['class_c'], null, ['a'], null, null, -201],
        'accepting': true,
        'ordered_children': {}
      },
      '6': {
        'type': 'rule',
        'rule_key': 4,
        'rule': ['A(BEFORE_CLASS_C)', null, null, ['a'], null, ['class_c'], -201],
        'accepting': true,
        'ordered_children': {}
      },
      '7': {
        'type': 'rule',
        'rule_key': 5,
        'rule': ['A', null, null, ['a'], null, null, -101],
        'accepting': true,
        'ordered_children': {}
      },
      '8': {
        'type': 'token',
        'token': 'b',
        'rule_children': [9],
        'ordered_children': {
          '__rules__': [9]
        }
      },
      '9': {
        'type': 'rule',
        'rule_key': 6,
        'rule': ['B', null, null, ['b'], null, null, -101],
        'accepting': true,
        'ordered_children': {}
      },
      '10': {
        'type': 'token',
        'token': 'c',
        'rule_children': [11],
        'ordered_children': {
          '__rules__': [11]
        }
      },
      '11': {
        'type': 'rule',
        'rule_key': 7,
        'rule': ['C', null, null, ['c'], null, null, -101],
        'accepting': true,
        'ordered_children': {}
      },
      '12': {
        'type': 'token',
        'token': ' ',
        'rule_children': [13],
        'ordered_children': {
          '__rules__': [13]
        }
      },
      '13': {
        'type': 'rule',
        'rule_key': 8,
        'rule': [' ', null, null, [' '], null, null, -101],
        'accepting': true,
        'ordered_children': {}
      }
    },
    'edge_list': [
      [0, 1],
      [1, 2],
      [1, 3],
      [1, 4],
      [1, 5],
      [1, 6],
      [1, 7],
      [0, 8],
      [8, 9],
      [0, 10],
      [10, 11],
      [0, 12],
      [12, 13]
    ]
  },
  '_tokens': {
    'a': ['class_a'],
    'b': ['class_b'],
    'c': ['class_c'],
    ' ': ['wb']
  },
  '_rules': [
    ['A(AFTER_BB_AND_CLASS_C)', ['class_c'],
      ['b', 'b'],
      ['a'], null, null, -403
    ],
    ['A(AFTER_B_AND_CLASS_C)', ['class_c'],
      ['b'],
      ['a'], null, null, -302
    ],
    ['A(BEFORE_C_AND_CLASS_B)', null, null, ['a'],
      ['c'],
      ['class_b'], -302
    ],
    ['A(AFTER_CLASS_C)', ['class_c'], null, ['a'], null, null, -201],
    ['A(BEFORE_CLASS_C)', null, null, ['a'], null, ['class_c'], -201],
    ['A', null, null, ['a'], null, null, -101],
    ['B', null, null, ['b'], null, null, -101],
    ['C', null, null, ['c'], null, null, -101],
    [' ', null, null, [' '], null, null, -101]
  ],
  '_onmatch_rules': [
    [
      ['class_a', 'class_b'],
      ['class_a', 'class_b'], '!'
    ],
    [
      ['class_a'],
      ['class_b'], ','
    ]
  ],
  '_onmatch_rules_lookup': {
    'a': {
      'b': [0]
    },
    'b': {
      'a': [1]
    }
  },
  '_whitespace': [' ', 'wb', true],
  '_tokenizer_pattern': '(a|b|c|\\ )'
}

describe('#GraphParser', function () {
  var parser = new GraphParser(settings)
  it('should parse rules with single token', function () {
    var result = parser.parse('a')
    expect(result).to.equal('A')
  })
  it('should parse rules with multiple tokens', function () {
    var result = parser.parse('aa')
    expect(result).to.equal('AA')
  })
  it('should parse rules with prev class', function () {
    var result = parser.parse('ca')
    expect(result).to.equal('CA(AFTER_CLASS_C)')
  })
  it('should parse rules with prev class and prev token', function () {
    var result = parser.parse('cba')
    expect(result).to.equal('CBA(AFTER_B_AND_CLASS_C)')
  })
  it('should parse rules with prev class and prev tokens', function () {
    var result = parser.parse('cbba')
    expect(result).to.equal('CBBA(AFTER_BB_AND_CLASS_C)')
  })
  it('should parse rules with next class', function () {
    var result = parser.parse('ac')
    expect(result).to.equal('A(BEFORE_CLASS_C)C')
  })
  it('should parse rules with next class and next tokens', function () {
    var result = parser.parse('acb')
    expect(result).to.equal('A(BEFORE_C_AND_CLASS_B)CB')
  })
  it('should parse rules with onmatch rule of length 1', function () {
    var result = parser.parse('ab')
    expect(result).to.equal('A,B')
  })
  it('should parse rules with longer onmatch rules', function () {
    var result = parser.parse('abab')
    expect(result).to.equal('A,B!A,B')
  })
  it('should consolidate whitespace', function () {
    var result = parser.parse(' ab')
    expect(result).to.equal('A,B')
  })
  it('should log an error if no input', function () {
    var result = parser.parse('')
    expect(result).to.equal('')
  })
})
