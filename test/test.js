/* eslint-env mocha */
'use strict'

var expect = require('chai').expect
var urdubiometerjs = require('../src/index.js')
var GraphParser = urdubiometerjs.GraphParser

/* Theses settings are generated by urdubiometer. The source YAML is:
      tokens:
        a: [class_a]
        b: [class_b]
        c: [class_c]
        " ": [wb]
      rules:
        a: A
        b: B
        <class_c> a: A(AFTER_CLASS_C)
        (<class_c> b) a: A(AFTER_B_AND_CLASS_C)
        (<class_c> b b) a: A(AFTER_BB_AND_CLASS_C)
        a <class_c>: A(BEFORE_CLASS_C)
        a (c <class_b>): A(BEFORE_C_AND_CLASS_B)
        c: C
      onmatch_rules:
        -
          <class_a> <class_b> + <class_a> <class_b>: "!"
        -
          <class_a> + <class_b>: ","
      whitespace:
        default: ' '
        consolidate: True
        token_class: wb
    """
 */

var settings = {'_graph': {'edge': {'0': {'1': {'token': 'a', 'cost': -401},
  '8': {'token': 'b', 'cost': -100},
  '10': {'token': 'c', 'cost': -100}},
'1':
{'2': {'cost': -401,
  'constraints': {'prev_classes': ['class_c'],
    'prev_tokens': ['b', 'b']}},
'3': {'cost': -301,
  'constraints':
{'prev_classes': ['class_c'], 'prev_tokens': ['b']}},
'4': {'cost': -301,
  'constraints': {'next_tokens': ['c'], 'next_classes': ['class_b']}},
'5':
{'cost': -201, 'constraints': {'prev_classes': ['class_c']}},
'6': {'cost':
-201,
'constraints': {'next_classes': ['class_c']}},
'7': {'cost': -100}},
'8':
{'9': {'cost': -100}},
'10': {'11': {'cost': -100}}},
'node': {'0': {'type':
'root',
'token_children': {'a': 1, 'b': 8, 'c': 10},
'ordered_children': {'a':
[1],
'b': [8],
'c': [10]}},
'1': {'type': 'token',
  'token': 'a',
  'rule_children': [2, 3, 4, 5, 6, 7],
  'ordered_children': {'__rules__': [2, 3,
    4, 5, 6, 7]}},
'2': {'type': 'rule',
  'rule_key': 0,
  'rule':
['A(AFTER_BB_AND_CLASS_C)', ['class_c'], ['b', 'b'], ['a'], null, null, -401],
  'accepting': true,
  'ordered_children': {}},
'3': {'type': 'rule',
  'rule_key':
1,
  'rule': ['A(AFTER_B_AND_CLASS_C)', ['class_c'], ['b'], ['a'], null, null,
    -301],
  'accepting': true,
  'ordered_children': {}},
'4': {'type': 'rule',
  'rule_key': 2,
  'rule': ['A(BEFORE_C_AND_CLASS_B)', null, null, ['a'], ['c'],
    ['class_b'], -301],
  'accepting': true,
  'ordered_children': {}},
'5': {'type':
'rule',
'rule_key': 3,
'rule': ['A(AFTER_CLASS_C)', ['class_c'], null, ['a'],
  null, null, -201],
'accepting': true,
'ordered_children': {}},
'6': {'type':
'rule',
'rule_key': 4,
'rule': ['A(BEFORE_CLASS_C)', null, null, ['a'], null,
  ['class_c'], -201],
'accepting': true,
'ordered_children': {}},
'7': {'type':
'rule',
'rule_key': 5,
'rule': ['A', null, null, ['a'], null, null, -100],
'accepting': true,
'ordered_children': {}},
'8': {'type': 'token',
  'token':
'b',
  'rule_children': [9],
  'ordered_children': {'__rules__': [9]}},
'9':
{'type': 'rule',
  'rule_key': 6,
  'rule': ['B', null, null, ['b'], null, null,
    -100],
  'accepting': true,
  'ordered_children': {}},
'10': {'type': 'token',
  'token': 'c',
  'rule_children': [11],
  'ordered_children': {'__rules__': [11]}},
'11': {'type': 'rule',
  'rule_key': 7,
  'rule': ['C', null, null, ['c'], null,
    null, -100],
  'accepting': true,
  'ordered_children': {}}},
'edge_list': [[0, 1],
  [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [0, 8], [8, 9], [0, 10], [10,
    11]]},
'_tokens': {'a': ['class_a'],
  'b': ['class_b'],
  'c': ['class_c'],
  ' ':
['wb']},
'_rules': [['A(AFTER_BB_AND_CLASS_C)', ['class_c'], ['b', 'b'], ['a'],
  null, null, -401], ['A(AFTER_B_AND_CLASS_C)', ['class_c'], ['b'], ['a'], null,
  null, -301], ['A(BEFORE_C_AND_CLASS_B)', null, null, ['a'], ['c'], ['class_b'],
  -301], ['A(AFTER_CLASS_C)', ['class_c'], null, ['a'], null, null, -201],
['A(BEFORE_CLASS_C)', null, null, ['a'], null, ['class_c'], -201], ['A', null,
  null, ['a'], null, null, -100], ['B', null, null, ['b'], null, null, -100],
['C', null, null, ['c'], null, null, -100]],
'_onmatch_rules': [[['class_a',
  'class_b'], ['class_a', 'class_b'], '!'], [['class_a'], ['class_b'], ',']],
'_onmatch_rules_lookup': {'a': {'b': [0]}, 'b': {'a': [1]}},
'_whitespace': [' ',
  'wb', true],
'_tokenizer_pattern': '(a|b|c|\\\\ )'}

describe('#GraphParser', function () {
  var parser = new GraphParser(settings)
  it('should parse rules with single token', function () {
    var result = parser.parse('a')
    expect(result).to.equal('A')
  })
  it('should parse rules with multiple tokens', function () {
    var result = parser.parse('aa')
    expect(result).to.equal('AA')
  })
  it('should parse rules with prev class', function () {
    var result = parser.parse('ca')
    expect(result).to.equal('CA(AFTER_CLASS_C)')
  })
  it('should parse rules with prev class and prev token', function () {
    var result = parser.parse('cba')
    expect(result).to.equal('CBA(AFTER_B_AND_CLASS_C)')
  })
  it('should parse rules with prev class and prev tokens', function () {
    var result = parser.parse('cbba')
    expect(result).to.equal('CBBA(AFTER_BB_AND_CLASS_C)')
  })
  it('should parse rules with next class', function () {
    var result = parser.parse('ac')
    expect(result).to.equal('A(BEFORE_CLASS_C)C')
  })
  it('should parse rules with next class and next tokens', function () {
    var result = parser.parse('acb')
    expect(result).to.equal('A(BEFORE_C_AND_CLASS_B)CB')
  })
  it('should parse rules with onmatch rule of length 1', function () {
    var result = parser.parse('ab')
    expect(result).to.equal('A,B')
  })
  it('should parse rules with longer onmatch rules', function () {
    var result = parser.parse('abab')
    expect(result).to.equal('A,B!A,B')
  })
})
